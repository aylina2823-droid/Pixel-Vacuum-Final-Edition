<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pixel Vacuum: Pro Edition</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            /* Интеграция с темой Telegram */
            --bg-color: var(--tg-theme-bg-color, #ffffff);
            --text-color: var(--tg-theme-text-color, #000000);
            --hint-color: var(--tg-theme-hint-color, #999999);
            --button-color: var(--tg-theme-button-color, #2481cc);
            --button-text: var(--tg-theme-button-text-color, #ffffff);
            --accent: #22d3ee;
            --gold: #facc15;
            --danger: #ef4444;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: none; /* Блокировка системных жестов */
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; position: fixed;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overscroll-behavior: none; /* Запрет bounce-эффекта */
        }

        #game-wrapper {
            position: relative;
            width: calc(100% - 20px);
            height: calc(100% - 140px);
            background: #050505; /* Внутреннее поле всегда темное для контраста пикселей */
            border-radius: 24px;
            overflow: hidden;
            border: 2px solid var(--button-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        canvas { display: block; width: 100%; height: 100%; }

        .ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        
        /* Верхняя панель */
        .top-bar {
            position: absolute; top: 15px; left: 0; right: 0;
            display: flex; justify-content: space-between; padding: 0 15px;
        }
        .stat-card {
            background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
            padding: 8px; border-radius: 12px; min-width: 80px; text-align: center;
        }
        .stat-label { font-size: 9px; text-transform: uppercase; opacity: 0.8; color: #eee; }
        .stat-value { font-size: 16px; font-weight: 800; color: #fff; }

        /* Контроллеры */
        .controls {
            display: flex; justify-content: center; gap: 10px; padding: 10px; width: 100%;
            pointer-events: auto;
        }
        .btn {
            flex: 1; max-width: 110px; height: 75px; border-radius: 16px; border: none;
            background: var(--button-color); color: var(--button-text);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: transform 0.1s, opacity 0.2s; position: relative;
        }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { opacity: 0.5; filter: grayscale(1); }
        
        .btn-lvl { font-size: 9px; font-weight: bold; position: absolute; top: 5px; opacity: 0.9; }
        .btn-label { font-size: 10px; font-weight: 900; margin-top: 15px; }
        .btn-price { font-size: 11px; font-weight: bold; color: var(--gold); }
        
        .locked { background: #444 !important; }

        #notif {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-weight: 900; font-size: 28px; pointer-events: none; z-index: 100; display: none;
            text-shadow: 0 0 15px rgba(0,0,0,0.8);
        }
        .animate-notif { display: block; animation: notifAnim 1.5s forwards; }
        @keyframes notifAnim { 0% { opacity:0; scale:0.5; } 20% { opacity:1; scale:1.1; } 100% { opacity:0; transform: translate(-50%, -100%); } }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="ui" class="ui-layer">
            <div class="top-bar">
                <div class="stat-card"><div class="stat-label">COINS</div><div class="stat-value" id="coins-val">0</div></div>
                <div class="stat-card"><div class="stat-label">BAG</div><div class="stat-value" id="bag-val">0%</div></div>
            </div>
        </div>
        <div id="notif"></div>
    </div>

    <div class="controls">
        <button class="btn" onclick="upgrade('power')" id="btn-power">
            <div class="btn-lvl" id="p-lvl">Lvl 0/20</div>
            <div class="btn-label" id="p-label">POWER</div>
            <div class="btn-price" id="p-price">50</div>
        </button>
        <button class="btn locked" onclick="activateTurbo()" id="btn-turbo">
            <div class="btn-lvl" id="t-lvl">Lvl 0/10</div>
            <div class="btn-label">TURBO</div>
            <div class="btn-price" id="t-price">LOCKED</div>
        </button>
        <button class="btn" onclick="upgrade('radius')" id="btn-radius">
            <div class="btn-lvl" id="r-lvl">Lvl 0/15</div>
            <div class="btn-label" id="r-label">RADIUS</div>
            <div class="btn-price" id="r-price">75</div>
        </button>
    </div>

    <script>
        // --- Telegram Integration ---
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();
        if (tg.disableVerticalSwipes) tg.disableVerticalSwipes();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Hard Caps ---
        const MAX_PWR = 20;
        const MAX_RAD = 15;
        const MAX_TRB = 10;
        const OFFSET_Y = 70;

        let state = JSON.parse(localStorage.getItem('pixel_vac_v4')) || {
            coins: 0, pLvl: 0, rLvl: 0, tLvl: 0, tPrice: 200, magnetPwr: 1
        };

        let pixels = [], clumps = [], mouse = { x: -100, y: -100, down: false };
        let lastTime = performance.now(), spawnAcc = 0, isTurbo = false, bagFill = 0;

        function haptic(style = 'medium') {
            try {
                tg.HapticFeedback.impactOccurred(style);
            } catch(e) {
                if(navigator.vibrate) navigator.vibrate(50);
            }
        }

        function init() {
            window.addEventListener('resize', resize);
            resize();
            // Блокировка свайпа через JS
            document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
            for(let i=0; i<60; i++) spawnPixel();
            requestAnimationFrame(loop);
        }

        function resize() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
        }

        function spawnPixel() {
            pixels.push({
                x: Math.random()*canvas.width, y: Math.random()*canvas.height,
                c: ['#22d3ee', '#4ade80', '#fb7185', '#facc15'][Math.floor(Math.random()*4)]
            });
        }

        function spawnClump() {
            const size = 6;
            const clump = {
                x: Math.random()*canvas.width, y: Math.random()*canvas.height,
                life: 1.8, active: false, 
                parts: Array.from({length: size}, () => ({dx: Math.random()*12-6, dy: Math.random()*12-6}))
            };
            clumps.push(clump);
        }

        function upgrade(type) {
            if(type === 'power') {
                if(state.pLvl >= MAX_PWR) return;
                let cost = Math.floor(50 * Math.pow(1.5, state.pLvl));
                if(state.coins >= cost) {
                    state.coins -= cost; state.pLvl++;
                    haptic('light');
                }
            } else if(type === 'radius') {
                if(state.rLvl >= MAX_RAD) {
                    // Магнетизм
                    let cost = 500 * state.magnetPwr;
                    if(state.coins >= cost) {
                        state.coins -= cost; state.magnetPwr++;
                        haptic('light');
                    }
                } else {
                    let cost = Math.floor(75 * Math.pow(1.6, state.rLvl));
                    if(state.coins >= cost) {
                        state.coins -= cost; state.rLvl++;
                        haptic('light');
                    }
                }
            }
            save();
        }

        function activateTurbo() {
            if(state.pLvl < MAX_PWR || isTurbo) return;
            isTurbo = true;
            haptic('medium');
            addMessage("TURBO ACTIVATED!");
            let duration = 3000 + (state.tLvl * 500);
            setTimeout(() => isTurbo = false, duration);
        }

        function loop(t) {
            const dt = (t - lastTime) / 1000;
            lastTime = t;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const tx = mouse.x, ty = mouse.y - OFFSET_Y;
            const rad = 50 + (state.rLvl * 8);
            const pwr = (1 + state.pLvl * 0.5) * (isTurbo ? 2 : 1) * state.magnetPwr;

            spawnAcc += dt;
            if(spawnAcc > 0.5) {
                if(pixels.length < 120) spawnPixel();
                if(Math.random() < 0.1 && clumps.length < 2) spawnClump();
                spawnAcc = 0;
            }

            // Визуал радиуса
            if(mouse.down) {
                ctx.beginPath();
                ctx.arc(tx, ty, rad, 0, Math.PI*2);
                ctx.fillStyle = isTurbo ? 'rgba(239, 68, 68, 0.15)' : 'rgba(34, 211, 238, 0.1)';
                ctx.fill();
            }

            // Пиксели
            for(let i=pixels.length-1; i>=0; i--) {
                let p = pixels[i];
                let dx = tx - p.x, dy = ty - p.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(mouse.down && dist < rad) {
                    let speed = Math.min(dist * 0.1 * pwr, 15);
                    p.x += (dx/dist) * speed; p.y += (dy/dist) * speed;
                    if(dist < 10) { 
                        state.coins += 1; bagFill = Math.min(100, bagFill + 0.1);
                        pixels.splice(i, 1); 
                    }
                }
                ctx.fillStyle = p.c; ctx.fillRect(p.x-2, p.y-2, 4, 4);
            }

            // Комки
            for(let i=clumps.length-1; i>=0; i--) {
                let c = clumps[i];
                let dx = tx - c.x, dy = ty - c.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if(mouse.down && dist < rad) {
                    if(!c.active) { c.active = true; haptic('medium'); }
                    c.life -= dt;
                    // Тряска
                    c.x += (Math.random()-0.5)*5; c.y += (Math.random()-0.5)*5;
                    // Всасывание центра
                    c.x += (dx/dist) * 2; c.y += (dy/dist) * 2;
                    if(c.life <= 0) {
                        state.coins += 20; bagFill = Math.min(100, bagFill + 2);
                        haptic('medium'); clumps.splice(i, 1); continue;
                    }
                } else { c.active = false; }
                
                ctx.fillStyle = '#777';
                c.parts.forEach(p => ctx.fillRect(c.x+p.dx, c.y+p.dy, 5, 5));
            }

            updateUI();
            requestAnimationFrame(loop);
        }

        function updateUI() {
            document.getElementById('coins-val').innerText = Math.floor(state.coins);
            document.getElementById('bag-val').innerText = Math.floor(bagFill) + '%';

            // Power
            const pLvlTxt = document.getElementById('p-lvl');
            const pBtn = document.getElementById('btn-power');
            pLvlTxt.innerText = `Lvl ${state.pLvl}/${MAX_PWR}`;
            if(state.pLvl >= MAX_PWR) {
                document.getElementById('p-label').innerText = "MAX POWER";
                document.getElementById('p-price').innerText = "READY";
            } else {
                let cost = Math.floor(50 * Math.pow(1.5, state.pLvl));
                document.getElementById('p-price').innerText = cost;
                pBtn.disabled = state.coins < cost;
            }

            // Radius / Magnetism
            const rLvlTxt = document.getElementById('r-lvl');
            const rBtn = document.getElementById('btn-radius');
            if(state.rLvl >= MAX_RAD) {
                rLvlTxt.innerText = `Magnet: Lvl ${state.magnetPwr}`;
                document.getElementById('r-label').innerText = "MAGNETISM";
                let mCost = 500 * state.magnetPwr;
                document.getElementById('r-price').innerText = mCost;
                rBtn.disabled = state.coins < mCost;
            } else {
                rLvlTxt.innerText = `Lvl ${state.rLvl}/${MAX_RAD}`;
                let cost = Math.floor(75 * Math.pow(1.6, state.rLvl));
                document.getElementById('r-price').innerText = cost;
                rBtn.disabled = state.coins < cost;
            }

            // Turbo
            const tBtn = document.getElementById('btn-turbo');
            if(state.pLvl >= MAX_PWR) {
                tBtn.classList.remove('locked');
                document.getElementById('t-price').innerText = isTurbo ? "ACTIVE" : "USE";
            }
        }

        function addMessage(txt) {
            const el = document.getElementById('notif');
            el.innerText = txt; el.classList.remove('animate-notif');
            void el.offsetWidth; el.classList.add('animate-notif');
        }

        function save() { localStorage.setItem('pixel_vac_v4', JSON.stringify(state)); }

        function handlePointer(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            mouse.x = clientX - rect.left;
            mouse.y = clientY - rect.top;
        }

        window.addEventListener('pointerdown', e => { mouse.down = true; handlePointer(e); });
        window.addEventListener('pointermove', e => { handlePointer(e); });
        window.addEventListener('pointerup', () => { mouse.down = false; save(); });

        init();
    </script>
</body>
</html>